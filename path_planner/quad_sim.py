from math import cos, sin, ceil

from numpy import array, sqrt, matmul, linalg, empty
from scipy import integrate


class TrajGen():
    def __init__(self, start_pos, des_pos, T, s_dot=[0, 0, 0], g_dot=[0, 0, 0], s_acc=[0, 0, 0],
                 g_acc=[0, 0, 0]):
        self.s_x = start_pos[0]
        self.s_y = start_pos[1]
        self.s_z = start_pos[2]

        self.g_x = des_pos[0]
        self.g_y = des_pos[1]
        self.g_z = des_pos[2]

        self.start_x_dot = s_dot[0]
        self.start_y_dot = s_dot[1]
        self.start_z_dot = s_dot[2]

        self.des_x_dot = g_dot[0]
        self.des_y_dot = g_dot[1]
        self.des_z_dot = g_dot[2]

        self.start_x_acc = s_acc[0]
        self.start_y_acc = s_acc[1]
        self.start_z_acc = s_acc[2]

        self.des_x_acc = g_acc[0]
        self.des_y_acc = g_acc[1]
        self.des_z_acc = g_acc[2]

        self.T = T

    def solve(self):
        A = array(
            [[0, 0, 0, 0, 0, 1],
             [self.T ** 5, self.T ** 4, self.T ** 3, self.T ** 2, self.T, 1],
             [0, 0, 0, 0, 1, 0],
             [5 * self.T ** 4, 4 * self.T ** 3, 3 * self.T ** 2, 2 * self.T, 1, 0],
             [0, 0, 0, 2, 0, 0],
             [20 * self.T ** 3, 12 * self.T ** 2, 6 * self.T, 2, 0, 0]
             ])

        b_x = array(
            [[self.s_x],
             [self.g_x],
             [self.start_x_dot],
             [self.des_x_dot],
             [self.start_x_acc],
             [self.des_x_acc]
             ])

        b_y = array(
            [[self.s_y],
             [self.g_y],
             [self.start_y_dot],
             [self.des_y_dot],
             [self.start_y_acc],
             [self.des_y_acc]
             ])

        b_z = array(
            [[self.s_z],
             [self.g_z],
             [self.start_z_dot],
             [self.des_z_dot],
             [self.start_z_acc],
             [self.des_z_acc]
             ])

        self.x_c = linalg.solve(A, b_x)
        self.y_c = linalg.solve(A, b_y)
        self.z_c = linalg.solve(A, b_z)


# Simulation parameters
g = 9.81
m = 2.6
Ixx = 1
Iyy = 1
Izz = 1
T = 5

# Proportional coefficients
kp_x = 1
kp_y = 1
kp_z = 1
kp_roll = 25
kp_pitch = 25
kp_yaw = 25

# Derivative coefficients
kd_x = 10
kd_y = 10
kd_z = 1


def quad_sim(x_c, y_c, z_c, wp):
    """
    Calculates the necessary thrust and torques for the quadrotor to
    follow the trajectory described by the sets of coefficients
    x_c, y_c, and z_c.
    """
    run = len(wp)
    x_pos = wp[0][1]
    y_pos = wp[0][1]
    z_pos = wp[0][2]
    x_dot = 0
    y_dot = 0
    z_dot = 0

    roll = 0
    pitch = 0
    yaw = 0
    roll_dot = 0
    pitch_dot = 0
    yaw_dot = 0

    des_yaw = 0

    dt = 0.2
    t = 0

    i = 0
    n_run = run - 1  # waypoints
    n_loop = int(ceil(T / dt))
    p_data = empty((n_loop * n_run, 2))
    for k in range(n_run):
        for j in range(n_loop):
            des_z_pos = calc_pos(z_c[i], t)
            des_z_dot = calc_dot(z_c[i], t)
            des_x_acc = calc_acc(x_c[i], t)
            des_y_acc = calc_acc(y_c[i], t)
            des_z_acc = calc_acc(z_c[i], t)

            thrust = m * (g + des_z_acc + kp_z * (des_z_pos - z_pos) + kd_z * (des_z_dot - z_dot))
            power = thrust * sqrt(x_dot ** 2 + y_dot ** 2 + z_dot ** 2)
            power = power[0]
            roll_torque = kp_roll * (((des_x_acc * sin(des_yaw) - des_y_acc * cos(des_yaw)) / g) - roll)

            pitch_torque = kp_pitch * (((des_x_acc * cos(des_yaw) - des_y_acc * sin(des_yaw)) / g) - pitch)

            yaw_torque = kp_yaw * (des_yaw - yaw)

            roll_dot += roll_torque * dt / Ixx
            pitch_dot += pitch_torque * dt / Iyy
            yaw_dot += yaw_torque * dt / Izz

            roll += roll_dot * dt
            pitch += pitch_dot * dt
            yaw += yaw_dot * dt

            R = rotation_matrix(roll, pitch, yaw)
            acc = (matmul(R, array([0, 0, thrust.item()]).T) - array([0, 0, m * g]).T) / m

            x_acc = acc[0]
            y_acc = acc[1]
            z_acc = acc[2]
            x_dot += x_acc * dt
            y_dot += y_acc * dt
            z_dot += z_acc * dt
            x_pos += x_dot * dt
            y_pos += y_dot * dt
            z_pos += z_dot * dt

            t += dt
            p_data[j + n_loop * k - 1][0] = power
            p_data[j + n_loop * k - 1][1] = t
        t = 0
        i = (i + 1) % run
    energy_consumption = integrate.cumtrapz(p_data[:, 0], p_data[:, 1], initial=0)[-1]

    return energy_consumption


def calc_pos(c, t):
    """
    Calculates a position given a set of quintic coefficients and a time.

    Args
        c: List of coefficients generated by a quintic polynomial
            trajectory generator.
        t: Time at which to calculate the position

    Returns
        Position
    """
    return c[0] * t ** 5 + c[1] * t ** 4 + c[2] * t ** 3 + c[3] * t ** 2 + c[4] * t + c[5]


def calc_dot(c, t):
    """
    Calculates a velocity given a set of quintic coefficients and a time.

    Args
        c: List of coefficients generated by a quintic polynomial
            trajectory generator.
        t: Time at which to calculate the velocity

    Returns
        Velocity
    """
    return 5 * c[0] * t ** 4 + 4 * c[1] * t ** 3 + 3 * c[2] * t ** 2 + 2 * c[3] * t + c[4]


def calc_acc(c, t):
    """
    Calculates an acceleration given a set of quintic coefficients and a time.

    Args
        c: List of coefficients generated by a quintic polynomial
            trajectory generator.
        t: Time at which to calculate the acceleration

    Returns
        Acceleration
    """
    return 20 * c[0] * t ** 3 + 12 * c[1] * t ** 2 + 6 * c[2] * t + 2 * c[3]


def rotation_matrix(roll, pitch, yaw):
    """
    Calculates the ZYX rotation matrix.

    Args
        Roll: Angular position about the x-axis in radians.
        Pitch: Angular position about the y-axis in radians.
        Yaw: Angular position about the z-axis in radians.

    Returns
        3x3 rotation matrix as NumPy array
    """
    return array(
        [[cos(yaw) * cos(pitch), -sin(yaw) * cos(roll) + cos(yaw) * sin(pitch) * sin(roll),
          sin(yaw) * sin(roll) + cos(yaw) * sin(pitch) * cos(roll)],
         [sin(yaw) * cos(pitch), cos(yaw) * cos(roll) + sin(yaw) * sin(pitch) * sin(roll),
          -cos(yaw) * sin(roll) + sin(yaw) * sin(pitch) * cos(roll)],
         [-sin(pitch), cos(pitch) * sin(roll), cos(pitch) * cos(yaw)]
         ])


def energy_from_waypoints(wp):
    """
    Calculates the x, y, z coefficients for the four segments
    of the trajectory
    """
    x_coeffs = [[] for _ in range(len(wp))]
    y_coeffs = [[] for _ in range(len(wp))]
    z_coeffs = [[] for _ in range(len(wp))]

    for i in range(len(wp) - 1):
        traj = TrajGen(wp[i], wp[(i + 1) % len(wp)], T)
        traj.solve()

        x_coeffs[i] = traj.x_c
        y_coeffs[i] = traj.y_c
        z_coeffs[i] = traj.z_c

    return quad_sim(x_coeffs, y_coeffs, z_coeffs, wp)


def main():
    waypoints = [[0, 0, 0], [0, 0, 5], [5, 0, 5], [5, 5, 5], [0, 5, 5], [0, 0, 5]]
    energy = energy_from_waypoints(waypoints)
    print("Energy Consumption : ", energy, "Joules")


if __name__ == "__main__":
    print(__file__)
    main()
